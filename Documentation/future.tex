\chapter{Future Work}
\label{sec:futurework}

\section{Visualizations}
\label{sec:future_viz}
\INITIAL{T}{he visualizations used so far} in this work demonstrate an adequate base level of functionality for achieving the desired results in most in-situ analysis scenarios. The obvious area for improvement here is in expanding the capabilities of the system to handle specific graphical tasks without the ad-hoc design of graphical classes. Because so much work has been done in recent decades in the field of formalizing visualization practices, some works have emerged which have had serious influences on most well-used libraries built for this task. One such work is "The Grammar of Graphics" by Leland Wilkinson \cite{Wilkinson2005}. 

\paragraph{Grammar of Graphics}
The Grammar of Graphics is a seminal work in the field of scientific visualization which defines a rigorous method for developing graphics based on the data and scenario presented.  This gives rigid reasoning behind the application of most common graphics in a scientific environment, and more tangibly has resulted in the creation of several graphics libraries which are capable of building any visualization described by the grammar. The book deals exclusively with static graphics as would be seen in a statistical or scientific analysis vs. some kind of interactive business visualization.

\paragraph{Libraries}
Though there have been several projects and software libraries based on the theoretical foundations laid out in The Grammar of Graphics since its publication, there are no such libraries available in java. The reasons for this are complex, but generally speaking major factors include the widespread use of languages other than java for analysis and the complexity of implementation in java over other environments. Typically, when scientific visualizations are needed analysts tend to turn to other languages in which a solution does exist.

\paragraph{R \& ggplot}
The statistical programming language R was purpose built with data analysis in mind. As such, it has a large user base across all scientific disciplines and has become a de facto standard for statistical computing and visualization. One of the most widely used libraries for visualization in R, is "ggplot" \cite{Hadley2006} which is based on "The Grammar of Graphics" and was first released only a year after the publication of the book. Ultimately, there is a strong argument for this library within R being the most convenient way of visualizing data by virtue of existing user base, documentation, and simple syntax alone. The difficulty of course is integrating R into the existing java code, though several approaches are available. 

\paragraph{R in Java}
There has been work in both directions of Java/R interoperability, with some R users desiring the performance or flexibility of specific java methods or libraries, and java users desiring the analytical tools provided by R. From R, the RJava project allows users to call java functions, and likewise the RCaller package allows java users to execute R code by making calls to a local script. The problem with such a method in the case of in-situ analytics lies in a reliance on the execution environment being configured for R. Additionally, with a library such as RCaller, there can be issues when executing in a cluster environment, as data transit has not been optimized for distribution beyond four nodes. A better solution in a project such as Renjin, which is a version of the R language written entirely in java, so that there are no requirements placed on the execution environment. For general purpose analytical R usage this is an elegant solution, but for visualization we rely on packages more than the R language itself, and the bulk of commonly used packages are written in C and have not yet been themselves rewritten to run under a JVM based environment such as a Renjin application.

\paragraph{Python}
Python, though newer than R is quickly becoming as popular in the realm of data science and statistical computing in general. Though it doesn't yet have the same array of scientific computing libraries as R, there are several ongoing projects which aim to close the gap. Of course high on the list of items to be developed for python was a version of ggplot. This work has been largely completed, save for minor changes which are still being made based on user feedback and some small aesthetic adjustments which are ongoing. Like in R, there are projects which aim to allow for the execution of python code in java and vice versa. On particularly popular option among such projects is Jython, which like Renjin is an implementation of the python language written entirely in java. Unfortunately, the exact same pitfall is encountered here, with the modules required to utilize the ggplot python library being built using C, and thus not usable in a JVM only environment. 

\paragraph{JyNi}
As opposed to the case with Renjin however, a compatibility layer has been developed for Jython with the express purpose of allowing the use of C based scientific python libraries in java applications. This compatibility layer is called "JyNi" \cite{RichtHoffer2013} and is still actively in development. Unfortunately, this active development means that as of the time of this writing, ggplot is one of several libraries which still presents issues even with the compatibility layer. This issues is expected to be resolved by the end of 2015, and thus will soon be a viable option for accessing a very robust visualization library.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Distribution}
\label{sec:distribution}
\INITIAL{D}{istribution in analysis systems} following the general mapreduce model all operate very similarly in concept. This means that generally speaking, we can expect the dataset to be mapped into a set of key-value pairs which are then partitioned across a cluster in a uniformly distributed way. Because we may want to examine the intermediate dataset at a point prior to a reduce operation which would centralize the dataset, we must collect it piecemeal from each node in the cluster. This is achieved by sending the datasets from each node in the cluster to the visualizer for summary. 

\paragraph{Message Passing}
Message passing allows us to invoke a send message call from each in-situ data collector operating on a shard of the complete data set, and then receiving it in the visualizer. The visualizer can perform whichever operations are needed in order to merge the datasets considering the original locations and timing in order to generate useful output. 

\paragraph{Patterns?}
I'm not sure yet if a specific pattern will apply.

\paragraph{RabbitMQ}
So far arbitrary.

\paragraph{Specifics}
Implementation details such as server locale etc.

